<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>무당벌레 피하기 (자이로+아이템)</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: sans-serif;
            flex-direction: column;
            overflow: hidden;
        }
        canvas {
            border: 1px solid black;
            background-color: #e0ffe0;
        }
        #controls-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #555;
            text-align: center;
        }
        #shield-info {
            margin-top: 5px;
            font-size: 0.9em;
            color: #33a;
            font-weight: bold;
            visibility: hidden;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 1.2em;
            margin-bottom: 15px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        #start-button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }
        #start-button:active {
            background-color: #3e8e41;
            transform: scale(0.98);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .hidden {
            display: none !important;
        }
        #debug-panel {
            margin-top: 10px;
            padding: 10px;
            border: 1px dashed #666;
            background-color: #f5f5f5;
            width: 400px;
            text-align: center;
        }
        #debug-info {
            font-size: 0.8em;
            color: #555;
        }
        #manual-start {
            position: relative;
            z-index: 1001;
        }
        #manual-start-btn {
            transition: all 0.3s;
        }
        #manual-start-btn:hover {
            transform: scale(1.05);
        }
        #manual-start-btn:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>
    <button id="start-button" style="z-index: 1000; position: relative;">게임 시작 및 센서 사용</button>

    <canvas id="gameCanvas" width="400" height="600" class="hidden"></canvas>
    <div id="controls-info" class="hidden">기기를 기울여 무당벌레를 움직이세요!<br>떨어지는 아이템을 획득하세요! (센서 권한 허용 필요)</div>
    <div id="shield-info" class="hidden">보호막 활성화! (화면 터치)</div>
    
    <!-- 디버깅 패널 추가 -->
    <div id="debug-panel" class="hidden">
        <button id="spawn-enemy">적 생성</button>
        <button id="spawn-item">아이템 생성</button>
        <button id="debug-info-btn">디버그 정보</button>
        <div id="debug-info"></div>
    </div>
    
    <!-- 수동 게임 시작 버튼 추가 -->
    <div id="manual-start" style="margin-top: 20px; display: none;">
        <button id="manual-start-btn" style="background-color: #ff5722; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">
            시작 버튼 문제 해결 - 여기를 클릭하세요
        </button>
    </div>

    <script>
        // 페이지 완전 로드 후 실행
        window.onload = function() {
            console.log("Window loaded");
            initGame();
        };
        
        function initGame() {
            // DOM 요소 가져오기
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const shieldInfoDiv = document.getElementById('shield-info');
            const controlsInfoDiv = document.getElementById('controls-info');
            const startButton = document.getElementById('start-button');
            const debugPanel = document.getElementById('debug-panel');
            const debugInfoDiv = document.getElementById('debug-info');
            
            console.log("Game elements initialized:", {
                canvas: !!canvas,
                context: !!ctx,
                startButton: !!startButton
            });
            
            // 버튼 확인
            if (!startButton) {
                console.error("Start button not found!");
                alert("시작 버튼을 찾을 수 없습니다. 페이지를 새로고침해주세요.");
                return;
            }
            
            // 디버그 모드 - 개발 중에는 true로 설정
            const DEBUG_MODE = true;
            
            if (DEBUG_MODE) {
                debugPanel.classList.remove('hidden');
                console.log("Debug mode enabled");
            }

        // 디버그 버튼 이벤트 설정
        document.getElementById('spawn-enemy').addEventListener('click', () => {
            if (isGameRunning) {
                spawnTestEnemy();
            }
        });
        
        document.getElementById('spawn-item').addEventListener('click', () => {
            if (isGameRunning) {
                spawnTestItem();
            }
        });
        
        document.getElementById('debug-info-btn').addEventListener('click', () => {
            if (isGameRunning) {
                showDebugInfo();
            }
        });

        // --- 게임 상태 변수 ---
        let player, enemies, items, projectiles, score, gameOver, animationFrameId, gameStartTime, lastUpdateTime;
        let isGameRunning = false;
        // 타이머
        let enemySpawnRate, lastEnemySpawnTime, itemSpawnRate, lastItemSpawnTime;

        // --- 플레이어 기본 설정 ---
        const playerBase = {
            radius: 15,
            color: 'gold',
            shieldActive: false,
            shieldDuration: 1500,
            shieldCooldown: 5000,
            shieldTimer: 0,
            shieldCooldownTimer: 0
        };

        // --- 자이로스코프 관련 변수 ---
        let beta = 0, gamma = 0;
        const SENSITIVITY = 2.5;

        // --- 게임 요소 설정 ---
        const enemyRadius = 10;
        const itemRadius = 8; // 아이템 크기

        // --- 게임 초기화 함수 ---
        function initializeGameVariables() {
            player = { ...playerBase, x: canvas.width / 2, y: canvas.height - 50 };
            enemies = [];
            items = []; // 아이템 배열 추가
            projectiles = []; // 발사체 배열 추가
            score = 0;
            gameOver = false;
            animationFrameId = null;
            gameStartTime = Date.now();
            lastUpdateTime = 0;
            beta = 0;
            gamma = 0;

            // 타이머 초기화
            enemySpawnRate = 1000;
            lastEnemySpawnTime = 0;
            itemSpawnRate = 5000; // 아이템은 더 드물게 생성
            lastItemSpawnTime = 0;

            // UI 초기화
            shieldInfoDiv.style.visibility = 'hidden';
            shieldInfoDiv.textContent = '보호막 활성화! (화면 터치)';
        }

        // --- 자이로스코프 이벤트 핸들러 ---
        function handleOrientation(event) {
            if (event.beta !== null) beta = event.beta;
            if (event.gamma !== null) gamma = event.gamma;

            let targetX = player.x + (gamma * SENSITIVITY * 0.1);
            let targetY = player.y + ((beta - 30) * SENSITIVITY * 0.05); // Y축 이동은 약간만

            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, targetX));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, targetY));
            
            if (DEBUG_MODE) {
                // 자이로스코프 값 디버깅
                if (Date.now() % 1000 < 50) { // 주기적으로만 출력
                    console.log("Gyro values:", {beta, gamma, playerX: player.x, playerY: player.y});
                }
            }
        }

        // --- 센서 접근 권한 요청 및 리스너 등록 ---
        function requestDeviceOrientation() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            startGame();
                        } else {
                            alert('자이로스코프 센서 사용 권한이 거부되었습니다.');
                            resetToInitialScreen(); // 시작 화면으로 복귀
                        }
                    })
                    .catch(error => {
                         console.error("DeviceOrientationEvent 권한 요청 에러:", error);
                         alert('센서 권한 요청 중 오류가 발생했습니다.');
                         resetToInitialScreen();
                    });
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                startGame();
            }
        }

        // --- 시작 버튼 클릭 이벤트 ---
        function startButtonHandler() {
            console.log("Start button clicked!");
            startButton.classList.add('hidden');
            canvas.classList.remove('hidden');
            controlsInfoDiv.classList.remove('hidden');
            requestDeviceOrientation();
        }
        
        // 여러 방식으로 이벤트 리스너 등록
        startButton.addEventListener('click', startButtonHandler);
        startButton.addEventListener('touchstart', function(e) {
            e.preventDefault(); // 터치 이벤트의 기본 동작 방지
            startButtonHandler();
        });
        
        // 수동 시작 버튼 표시 및 이벤트 등록
        setTimeout(function() {
            const manualStartDiv = document.getElementById('manual-start');
            const manualStartBtn = document.getElementById('manual-start-btn');
            
            if (manualStartDiv && manualStartBtn) {
                manualStartDiv.style.display = 'block';
                manualStartBtn.addEventListener('click', startButtonHandler);
                manualStartBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    startButtonHandler();
                });
            }
        }, 2000); // 2초 후에 수동 시작 버튼 표시

        // --- 화면 터치/클릭 이벤트 (보호막 활성화, 재시작) ---
        function handleInteractionStart(e) {
            if (e) e.preventDefault(); // 모바일 터치 기본 동작 방지

            if (gameOver) {
                // 게임 오버 시: 초기 화면으로 돌아가기
                gameOver = false;
                isGameRunning = false;
                resetToInitialScreen();
            } else if (isGameRunning && !player.shieldActive && player.shieldCooldownTimer <= 0) {
                // 게임 실행 중: 보호막 활성화
                activateShield();
            }
        }
        canvas.addEventListener('touchstart', handleInteractionStart);
        canvas.addEventListener('mousedown', handleInteractionStart); // PC 테스트용

        // --- 보호막 활성화 함수 ---
        function activateShield() {
            player.shieldActive = true;
            player.shieldTimer = player.shieldDuration;
            player.shieldCooldownTimer = player.shieldCooldown;
            shieldInfoDiv.style.visibility = 'visible';
            shieldInfoDiv.textContent = '보호막 활성화!';
            console.log("Shield Activated!");

            setTimeout(() => {
                player.shieldActive = false;
                shieldInfoDiv.style.visibility = 'hidden';
                console.log("Shield Deactivated!");
            }, player.shieldDuration);
        }

        // --- 적 생성 함수 ---
        function spawnEnemy(currentTime) {
            if (currentTime - lastEnemySpawnTime < enemySpawnRate) return; // 생성 주기 체크

            const x = Math.random() * (canvas.width - enemyRadius * 2) + enemyRadius;
            const y = -enemyRadius;
            const speed = 2 + Math.random() * 2 + (Date.now() - gameStartTime) / 20000;
            const type = Math.random() < 0.3 ? 'zigzag' : 'normal'; // 30% 확률로 지그재그 타입
            let enemyData = { x, y, radius: enemyRadius, speed, type };

            if (type === 'normal') {
                enemyData.color = 'red';
            } else { // zigzag
                enemyData.color = 'purple';
                enemyData.width = enemyRadius * 1.5; // 사각형 모양
                enemyData.height = enemyRadius * 1.5;
                enemyData.dx = Math.random() < 0.5 ? 2 : -2; // 초기 좌우 이동 방향
            }
            enemies.push(enemyData);
            
            if (DEBUG_MODE) {
                console.log(`Enemy spawned: ${type} at (${x}, ${y}). Total: ${enemies.length}`);
            }

            lastEnemySpawnTime = currentTime;
            enemySpawnRate = Math.max(200, 1000 - (Date.now() - gameStartTime) / 100); // 난이도 상승
        }

        // --- 아이템 생성 함수 ---
        function spawnItem(currentTime) {
            if (currentTime - lastItemSpawnTime < itemSpawnRate) return; // 생성 주기 체크

            const x = Math.random() * (canvas.width - itemRadius * 2) + itemRadius;
            const y = -itemRadius;
            const speed = 1.5 + Math.random(); // 아이템은 조금 느리게
            const rand = Math.random();
            let itemData = { x, y, speed };

            if (rand < 0.4) { // 40% 점수
                itemData.type = 'score';
                itemData.radius = itemRadius;
                itemData.color = 'lime'; // 초록색 동그라미
            } else if (rand < 0.7) { // 30% 벌 미사일
                itemData.type = 'bee';
                itemData.width = itemRadius * 2.5; // 노란색 직사각형
                itemData.height = itemRadius * 1.5;
                itemData.color = 'yellow';
            } else { // 30% 나뭇잎
                itemData.type = 'leaf';
                itemData.radius = itemRadius * 1.2; // 녹색 삼각형
                itemData.color = 'green';
            }
            items.push(itemData);
            
            if (DEBUG_MODE) {
                console.log(`Item spawned: ${itemData.type} at (${x}, ${y}). Total: ${items.length}`);
            }
            
            lastItemSpawnTime = currentTime;
            itemSpawnRate = Math.max(3000, 5000 - (Date.now() - gameStartTime) / 150); // 아이템 생성 간격도 약간 줄임
        }

        // --- 아이템 효과 발동 함수 ---
        function activateItemEffect(itemType, playerX, playerY) {
            console.log("Item collected:", itemType);
            if (itemType === 'score') {
                score += 200;
            } else if (itemType === 'bee') {
                // 벌 미사일 발사
                projectiles.push({
                    x: playerX,
                    y: playerY - player.radius, // 플레이어 바로 위에서 시작
                    width: 20,
                    height: 30,
                    color: 'orange',
                    speed: -3, // 위로 느리게 이동
                    type: 'bee'
                });
            } else if (itemType === 'leaf') {
                // 나뭇잎 여러 개 발사
                for (let i = 0; i < 5; i++) {
                    projectiles.push({
                        x: playerX,
                        y: playerY,
                        radius: 5,
                        color: 'darkgreen',
                        speed: 5, // 빠르게
                        angle: (Math.random() * Math.PI / 2) + Math.PI * 1.25, // 위쪽 랜덤 방향 (1.25pi ~ 1.75pi)
                        type: 'leaf'
                    });
                }
            }
        }

        // --- 충돌 감지 함수 (원 vs 원) ---
        function detectCircleCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < circle1.radius + circle2.radius;
        }
        // --- 충돌 감지 함수 (원 vs 사각형) ---
        function detectRectCollision(circle, rect) {
             // 가장 가까운 사각형 위의 점 찾기
            const closestX = Math.max(rect.x - rect.width / 2, Math.min(circle.x, rect.x + rect.width / 2));
            const closestY = Math.max(rect.y - rect.height / 2, Math.min(circle.y, rect.y + rect.height / 2));

            const dx = circle.x - closestX;
            const dy = circle.y - closestY;
            const distanceSquared = (dx * dx) + (dy * dy);
            return distanceSquared < (circle.radius * circle.radius);
        }


        // --- 게임 업데이트 함수 ---
        function update(currentTime) {
            if (gameOver || !isGameRunning) return;

            const deltaTime = currentTime - (lastUpdateTime || currentTime);
            lastUpdateTime = currentTime;

            // 보호막 타이머 업데이트
            if (player.shieldTimer > 0) player.shieldTimer -= deltaTime;
            if (player.shieldCooldownTimer > 0) {
                player.shieldCooldownTimer -= deltaTime;
                 if (!player.shieldActive) {
                    shieldInfoDiv.textContent = `보호막 대기: ${Math.ceil(player.shieldCooldownTimer / 1000)}초`;
                    shieldInfoDiv.style.visibility = 'visible';
                 }
            } else if (!player.shieldActive) {
                 shieldInfoDiv.style.visibility = 'hidden';
                 shieldInfoDiv.textContent = '보호막 활성화! (화면 터치)';
            }

            // 적 생성
            spawnEnemy(currentTime);
            // 아이템 생성
            spawnItem(currentTime);

            // 디버그 모드에서는 주기적으로 객체 상태 출력
            if (DEBUG_MODE && currentTime % 3000 < 20) {
                showDebugInfo();
            }

            // 적 이동 및 플레이어 충돌 처리
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += enemy.speed;

                // 지그재그 이동 처리
                if (enemy.type === 'zigzag') {
                    enemy.x += enemy.dx;
                    // 벽 충돌 시 방향 전환
                    if (enemy.x - enemy.width/2 < 0 || enemy.x + enemy.width/2 > canvas.width) {
                        enemy.dx *= -1;
                    }
                }

                // 화면 밖 제거
                if (enemy.y > canvas.height + (enemy.radius || enemy.height)) {
                    enemies.splice(i, 1);
                    if (!gameOver) score += 10; // 게임오버 아닐 때만 점수 추가
                    continue; // 다음 적으로 이동
                }

                // 플레이어와 충돌 감지
                let collided = false;
                if (enemy.type === 'normal') {
                    collided = detectCircleCollision(player, enemy);
                } else { // zigzag (사각형)
                     // 사각형 중심 좌표 기준으로 충돌 감지 함수 호출
                    collided = detectRectCollision(player, {
                        x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height
                    });
                }

                if (collided) {
                    if (player.shieldActive) {
                        enemies.splice(i, 1);
                        if (!gameOver) score += 50;
                    } else {
                        gameOver = true;
                        isGameRunning = false;
                        window.removeEventListener('deviceorientation', handleOrientation);
                        console.log("Game Over.");
                        break; // 루프 종료
                    }
                }
            } // 적 루프 끝

            // 아이템 이동 및 플레이어 충돌 처리
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.y += item.speed;

                // 화면 밖 제거
                if (item.y > canvas.height + (item.radius || item.height)) {
                    items.splice(i, 1);
                    continue;
                }

                // 플레이어와 충돌 감지
                let itemCollided = false;
                 if (item.type === 'score' || item.type === 'leaf') { // 원형 아이템
                    itemCollided = detectCircleCollision(player, item);
                 } else { // bee (사각형 아이템)
                     itemCollided = detectRectCollision(player, {
                         x: item.x, y: item.y, width: item.width, height: item.height
                     });
                 }

                if (itemCollided) {
                    activateItemEffect(item.type, player.x, player.y);
                    items.splice(i, 1); // 아이템 제거
                }
            } // 아이템 루프 끝

            // 발사체 이동 및 적 충돌 처리
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];

                // 발사체 이동
                if (proj.type === 'bee') {
                    proj.y += proj.speed; // speed가 음수이므로 위로 이동
                } else if (proj.type === 'leaf') {
                    proj.x += Math.cos(proj.angle) * proj.speed;
                    proj.y += Math.sin(proj.angle) * proj.speed;
                }

                // 화면 밖 제거
                if (proj.y < -proj.height || proj.y > canvas.height || proj.x < 0 || proj.x > canvas.width) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // 적과 충돌 감지
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    let projCollided = false;

                    // 발사체(원 또는 사각형)와 적(원 또는 사각형) 충돌 감지
                    let projShape = proj.type === 'bee' ? { x: proj.x, y: proj.y, width: proj.width, height: proj.height } : { x: proj.x, y: proj.y, radius: proj.radius };
                    let enemyShape = enemy.type === 'normal' ? { x: enemy.x, y: enemy.y, radius: enemy.radius } : { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height };

                    if (proj.type === 'bee') { // 벌(사각형) vs 적
                        if (enemy.type === 'normal') { // vs 일반적(원)
                             projCollided = detectRectCollision(enemyShape, projShape);
                        } else { // vs 지그재그적(사각형) - 사각형 vs 사각형 충돌 (간단하게 중심 거리로 대체)
                            const dx = proj.x - enemy.x;
                            const dy = proj.y - enemy.y;
                            projCollided = Math.abs(dx) * 2 < (proj.width + enemy.width) && Math.abs(dy) * 2 < (proj.height + enemy.height);
                        }
                    } else { // 잎(원) vs 적
                         if (enemy.type === 'normal') { // vs 일반적(원)
                             projCollided = detectCircleCollision(projShape, enemyShape);
                         } else { // vs 지그재그적(사각형)
                             projCollided = detectRectCollision(projShape, enemyShape);
                         }
                    }


                    if (projCollided) {
                        enemies.splice(j, 1); // 적 제거
                        projectiles.splice(i, 1); // 발사체 제거
                        if (!gameOver) score += 30; // 발사체로 적 제거 시 점수
                        break; // 현재 발사체는 제거되었으므로 내부 루프 탈출
                    }
                }
            } // 발사체 루프 끝
        } // 업데이트 함수 끝

         // --- 그리기 함수 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!isGameRunning && !gameOver) return;

            // 플레이어 그리기
            ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2); ctx.fillStyle = player.color; ctx.fill(); ctx.closePath();
            // 보호막 그리기
            if (player.shieldActive) {
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)'; ctx.lineWidth = 3; ctx.stroke(); ctx.closePath();
            }

            // 적 그리기
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                if (enemy.type === 'normal') {
                    ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2); ctx.fill(); ctx.closePath();
                } else { // zigzag (사각형)
                    // 중심 좌표 기준으로 그리기
                    ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
                }
            });

            // 아이템 그리기
            items.forEach(item => {
                ctx.fillStyle = item.color;
                if (item.type === 'score' || item.type === 'leaf') { // 원형 또는 삼각형
                    if(item.type === 'leaf') { // 삼각형 그리기
                        ctx.beginPath();
                        ctx.moveTo(item.x, item.y - item.radius); // Top vertex
                        ctx.lineTo(item.x - item.radius * Math.cos(Math.PI / 6), item.y + item.radius * Math.sin(Math.PI / 6)); // Bottom left
                        ctx.lineTo(item.x + item.radius * Math.cos(Math.PI / 6), item.y + item.radius * Math.sin(Math.PI / 6)); // Bottom right
                        ctx.closePath();
                        ctx.fill();
                    } else { // 원형 (점수)
                        ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.closePath();
                    }
                } else { // bee (사각형)
                     ctx.fillRect(item.x - item.width / 2, item.y - item.height / 2, item.width, item.height);
                }
            });

             // 발사체 그리기
            projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                if (proj.type === 'bee') {
                    ctx.fillRect(proj.x - proj.width / 2, proj.y - proj.height / 2, proj.width, proj.height);
                } else if (proj.type === 'leaf') {
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2); ctx.fill(); ctx.closePath();
                }
            });

            // 점수 표시
            ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.textAlign = 'left';
            ctx.fillText('Score: ' + score, 10, 30);

            // 게임 오버 표시
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);
                ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.font = '20px Arial';
                ctx.fillText('Tap to Restart', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        // --- 게임 루프 ---
        function gameLoop(currentTime) {
            if (!isGameRunning && !gameOver) {
                 animationFrameId = requestAnimationFrame(gameLoop);
                 return;
            }
            if (gameOver) {
                 draw(); // 마지막 게임 오버 화면
                 return;
            }

            update(currentTime);
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- 게임 시작 함수 ---
        function startGame() {
            if (isGameRunning) return;
            initializeGameVariables();
            isGameRunning = true;
            lastEnemySpawnTime = Date.now(); // 적 생성 타이머 시작 시간
            lastItemSpawnTime = Date.now(); // 아이템 생성 타이머 시작 시간
            console.log("Game started.");
            
            // 디버그 모드에서는 시작 즉시 테스트 객체 생성
            if (DEBUG_MODE) {
                setTimeout(() => {
                    spawnTestEnemy();
                    spawnTestItem();
                }, 1000);
            }
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- 초기 화면으로 복귀 함수 ---
        function resetToInitialScreen() {
             startButton.classList.remove('hidden');
             canvas.classList.add('hidden');
             controlsInfoDiv.classList.add('hidden');
             shieldInfoDiv.classList.add('hidden');
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             if (animationFrameId) cancelAnimationFrame(animationFrameId); // 루프 중지
             window.removeEventListener('deviceorientation', handleOrientation); // 리스너 제거
             console.log("Reset to initial screen.");
        }

        // PC용 키보드 컨트롤 (기기 센서 없을 때 사용)
        window.addEventListener('keydown', function(e) {
            // 게임이 실행 중일 때만 키보드 입력 처리
            if (isGameRunning) {
                if (e.key === 'ArrowLeft') {
                    player.x = Math.max(player.radius, player.x - 10);
                }
                else if (e.key === 'ArrowRight') {
                    player.x = Math.min(canvas.width - player.radius, player.x + 10);
                }
                else if (e.key === 'ArrowUp') {
                    player.y = Math.max(player.radius, player.y - 10);
                }
                else if (e.key === 'ArrowDown') {
                    player.y = Math.min(canvas.height - player.radius, player.y + 10);
                }
                else if (e.key === ' ' && !player.shieldActive && player.shieldCooldownTimer <= 0) {
                    // 스페이스바로 보호막 활성화
                    activateShield();
                }
            }
        });
        
        // 테스트 객체 생성 함수
        function spawnTestEnemy() {
            enemies.push({
                x: Math.random() * (canvas.width - 20) + 10,
                y: -20,
                radius: enemyRadius,
                speed: 2,
                type: 'normal',
                color: 'red'
            });
            
            console.log("Test enemy spawned. Total enemies:", enemies.length);
        }
        
        function spawnTestItem() {
            const types = ['score', 'bee', 'leaf'];
            const type = types[Math.floor(Math.random() * types.length)];
            let item = {
                x: Math.random() * (canvas.width - 20) + 10,
                y: -20,
                speed: 1.5,
                type: type
            };
            
            if (type === 'score' || type === 'leaf') {
                item.radius = itemRadius;
                item.color = type === 'score' ? 'lime' : 'green';
            } else { // bee
                item.width = itemRadius * 2.5;
                item.height = itemRadius * 1.5;
                item.color = 'yellow';
            }
            
            items.push(item);
            console.log("Test item spawned:", type, ". Total items:", items.length);
        }
        
        // 디버그 정보 표시
        function showDebugInfo() {
            if (!debugInfoDiv) return;
            
            const info = `
                <strong>Game Status:</strong> ${isGameRunning ? 'Running' : 'Stopped'}<br>
                <strong>Player:</strong> (${Math.round(player.x)}, ${Math.round(player.y)})<br>
                <strong>Shield:</strong> ${player.shieldActive ? 'Active' : 'Inactive'}<br>
                <strong>Enemies:</strong> ${enemies.length}<br>
                <strong>Items:</strong> ${items.length}<br>
                <strong>Projectiles:</strong> ${projectiles.length}<br>
                <strong>Score:</strong> ${score}
            `;
            
            debugInfoDiv.innerHTML = info;
            console.log("Game state:", {
                running: isGameRunning,
                enemies: enemies.length,
                items: items.length,
                projectiles: projectiles.length
            });
        }
