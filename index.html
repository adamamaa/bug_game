<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>무당벌레 피하기 (자이로+아이템)</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: sans-serif;
            flex-direction: column;
            overflow: hidden;
        }
        canvas {
            border: 1px solid black;
            background-color: #e0ffe0;
        }
        #controls-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #555;
            text-align: center;
        }
        #shield-info {
            margin-top: 5px;
            font-size: 0.9em;
            color: #33a;
            font-weight: bold;
            visibility: hidden;
        }
        #start-button {
            padding: 10px 20px;
            font-size: 1.2em;
            margin-bottom: 15px;
            cursor: pointer;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <button id="start-button">게임 시작 및 센서 사용</button>

    <canvas id="gameCanvas" width="400" height="600" class="hidden"></canvas>
    <div id="controls-info" class="hidden">기기를 기울여 무당벌레를 움직이세요!<br>떨어지는 아이템을 획득하세요! (센서 권한 허용 필요)</div>
    <div id="shield-info" class="hidden">보호막 활성화! (화면 터치)</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const shieldInfoDiv = document.getElementById('shield-info');
        const controlsInfoDiv = document.getElementById('controls-info');
        const startButton = document.getElementById('start-button');

        // --- 게임 상태 변수 ---
        let player, enemies, items, projectiles, score, gameOver, animationFrameId, gameStartTime, lastUpdateTime;
        let isGameRunning = false;
        // 타이머
        let enemySpawnRate, lastEnemySpawnTime, itemSpawnRate, lastItemSpawnTime;

        // --- 플레이어 기본 설정 ---
        const playerBase = {
            radius: 15,
            color: 'gold',
            shieldActive: false,
            shieldDuration: 1500,
            shieldCooldown: 5000,
            shieldTimer: 0,
            shieldCooldownTimer: 0
        };

        // --- 자이로스코프 관련 변수 ---
        let beta = 0, gamma = 0;
        const SENSITIVITY = 2.5;

        // --- 게임 요소 설정 ---
        const enemyRadius = 10;
        const itemRadius = 8; // 아이템 크기

        // --- 게임 초기화 함수 ---
        function initializeGameVariables() {
            player = { ...playerBase, x: canvas.width / 2, y: canvas.height - 50 };
            enemies = [];
            items = []; // 아이템 배열 추가
            projectiles = []; // 발사체 배열 추가
            score = 0;
            gameOver = false;
            animationFrameId = null;
            gameStartTime = Date.now();
            lastUpdateTime = 0;
            beta = 0;
            gamma = 0;

            // 타이머 초기화
            enemySpawnRate = 1000;
            lastEnemySpawnTime = 0;
            itemSpawnRate = 5000; // 아이템은 더 드물게 생성
            lastItemSpawnTime = 0;

            // UI 초기화
            shieldInfoDiv.style.visibility = 'hidden';
            shieldInfoDiv.textContent = '보호막 활성화! (화면 터치)';
        }

        // --- 자이로스코프 이벤트 핸들러 ---
        function handleOrientation(event) {
            if (event.beta !== null) beta = event.beta;
            if (event.gamma !== null) gamma = event.gamma;

            let targetX = player.x + (gamma * SENSITIVITY * 0.1);
            let targetY = player.y + ((beta - 30) * SENSITIVITY * 0.05); // Y축 이동은 약간만

            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, targetX));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, targetY));
        }

        // --- 센서 접근 권한 요청 및 리스너 등록 ---
        function requestDeviceOrientation() {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation);
                            startGame();
                        } else {
                            alert('자이로스코프 센서 사용 권한이 거부되었습니다.');
                            resetToInitialScreen(); // 시작 화면으로 복귀
                        }
                    })
                    .catch(error => {
                         console.error("DeviceOrientationEvent 권한 요청 에러:", error);
                         alert('센서 권한 요청 중 오류가 발생했습니다.');
                         resetToInitialScreen();
                    });
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                startGame();
            }
        }

        // --- 시작 버튼 클릭 이벤트 ---
        startButton.addEventListener('click', () => {
            startButton.classList.add('hidden');
            canvas.classList.remove('hidden');
            controlsInfoDiv.classList.remove('hidden');
            requestDeviceOrientation();
        });

        // --- 화면 터치/클릭 이벤트 (보호막 활성화, 재시작) ---
        function handleInteractionStart(e) {
            if (e) e.preventDefault(); // 모바일 터치 기본 동작 방지

            if (gameOver) {
                // 게임 오버 시: 초기 화면으로 돌아가기
                gameOver = false;
                isGameRunning = false;
                resetToInitialScreen();
            } else if (isGameRunning && !player.shieldActive && player.shieldCooldownTimer <= 0) {
                // 게임 실행 중: 보호막 활성화
                activateShield();
            }
        }
        canvas.addEventListener('touchstart', handleInteractionStart);
        canvas.addEventListener('mousedown', handleInteractionStart); // PC 테스트용

        // --- 보호막 활성화 함수 ---
        function activateShield() {
            player.shieldActive = true;
            player.shieldTimer = player.shieldDuration;
            player.shieldCooldownTimer = player.shieldCooldown;
            shieldInfoDiv.style.visibility = 'visible';
            shieldInfoDiv.textContent = '보호막 활성화!';
            console.log("Shield Activated!");

            setTimeout(() => {
                player.shieldActive = false;
                shieldInfoDiv.style.visibility = 'hidden';
                console.log("Shield Deactivated!");
            }, player.shieldDuration);
        }

        // --- 적 생성 함수 ---
        function spawnEnemy(currentTime) {
            if (currentTime - lastEnemySpawnTime < enemySpawnRate) return; // 생성 주기 체크

            const x = Math.random() * (canvas.width - enemyRadius * 2) + enemyRadius;
            const y = -enemyRadius;
            const speed = 2 + Math.random() * 2 + (Date.now() - gameStartTime) / 20000;
            const type = Math.random() < 0.3 ? 'zigzag' : 'normal'; // 30% 확률로 지그재그 타입
            let enemyData = { x, y, radius: enemyRadius, speed, type };

            if (type === 'normal') {
                enemyData.color = 'red';
            } else { // zigzag
                enemyData.color = 'purple';
                enemyData.width = enemyRadius * 1.5; // 사각형 모양
                enemyData.height = enemyRadius * 1.5;
                enemyData.dx = Math.random() < 0.5 ? 2 : -2; // 초기 좌우 이동 방향
            }
            enemies.push(enemyData);

            lastEnemySpawnTime = currentTime;
            enemySpawnRate = Math.max(200, 1000 - (Date.now() - gameStartTime) / 100); // 난이도 상승
        }

        // --- 아이템 생성 함수 ---
        function spawnItem(currentTime) {
            if (currentTime - lastItemSpawnTime < itemSpawnRate) return; // 생성 주기 체크

            const x = Math.random() * (canvas.width - itemRadius * 2) + itemRadius;
            const y = -itemRadius;
            const speed = 1.5 + Math.random(); // 아이템은 조금 느리게
            const rand = Math.random();
            let itemData = { x, y, speed };

            if (rand < 0.4) { // 40% 점수
                itemData.type = 'score';
                itemData.radius = itemRadius;
                itemData.color = 'lime'; // 초록색 동그라미
            } else if (rand < 0.7) { // 30% 벌 미사일
                itemData.type = 'bee';
                itemData.width = itemRadius * 2.5; // 노란색 직사각형
                itemData.height = itemRadius * 1.5;
                itemData.color = 'yellow';
            } else { // 30% 나뭇잎
                itemData.type = 'leaf';
                itemData.radius = itemRadius * 1.2; // 녹색 삼각형
                itemData.color = 'green';
            }
            items.push(itemData);
            lastItemSpawnTime = currentTime;
            itemSpawnRate = Math.max(3000, 5000 - (Date.now() - gameStartTime) / 150); // 아이템 생성 간격도 약간 줄임
        }

        // --- 아이템 효과 발동 함수 ---
        function activateItemEffect(itemType, playerX, playerY) {
            console.log("Item collected:", itemType);
            if (itemType === 'score') {
                score += 200;
            } else if (itemType === 'bee') {
                // 벌 미사일 발사
                projectiles.push({
                    x: playerX,
                    y: playerY - player.radius, // 플레이어 바로 위에서 시작
                    width: 20,
                    height: 30,
                    color: 'orange',
                    speed: -3, // 위로 느리게 이동
                    type: 'bee'
                });
            } else if (itemType === 'leaf') {
                // 나뭇잎 여러 개 발사
                for (let i = 0; i < 5; i++) {
                    projectiles.push({
                        x: playerX,
                        y: playerY,
                        radius: 5,
                        color: 'darkgreen',
                        speed: 5, // 빠르게
                        angle: (Math.random() * Math.PI / 2) + Math.PI * 1.25, // 위쪽 랜덤 방향 (1.25pi ~ 1.75pi)
                        type: 'leaf'
                    });
                }
            }
        }

        // --- 충돌 감지 함수 (원 vs 원) ---
        function detectCircleCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < circle1.radius + circle2.radius;
        }
        // --- 충돌 감지 함수 (원 vs 사각형) ---
        function detectRectCollision(circle, rect) {
             // 가장 가까운 사각형 위의 점 찾기
            const closestX = Math.max(rect.x - rect.width / 2, Math.min(circle.x, rect.x + rect.width / 2));
            const closestY = Math.max(rect.y - rect.height / 2, Math.min(circle.y, rect.y + rect.height / 2));

            const dx = circle.x - closestX;
            const dy = circle.y - closestY;
            const distanceSquared = (dx * dx) + (dy * dy);
            return distanceSquared < (circle.radius * circle.radius);
        }


        // --- 게임 업데이트 함수 ---
        function update(currentTime) {
            if (gameOver || !isGameRunning) return;

            const deltaTime = currentTime - (lastUpdateTime || currentTime);
            lastUpdateTime = currentTime;

            // 보호막 타이머 업데이트
            if (player.shieldTimer > 0) player.shieldTimer -= deltaTime;
            if (player.shieldCooldownTimer > 0) {
                player.shieldCooldownTimer -= deltaTime;
                 if (!player.shieldActive) {
                    shieldInfoDiv.textContent = `보호막 대기: ${Math.ceil(player.shieldCooldownTimer / 1000)}초`;
                    shieldInfoDiv.style.visibility = 'visible';
                 }
            } else if (!player.shieldActive) {
                 shieldInfoDiv.style.visibility = 'hidden';
                 shieldInfoDiv.textContent = '보호막 활성화! (화면 터치)';
            }

            // 적 생성
            spawnEnemy(currentTime);
            // 아이템 생성
            spawnItem(currentTime);

            // 적 이동 및 플레이어 충돌 처리
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += enemy.speed;

                // 지그재그 이동 처리
                if (enemy.type === 'zigzag') {
                    enemy.x += enemy.dx;
                    // 벽 충돌 시 방향 전환
                    if (enemy.x - enemy.width/2 < 0 || enemy.x + enemy.width/2 > canvas.width) {
                        enemy.dx *= -1;
                    }
                }

                // 화면 밖 제거
                if (enemy.y > canvas.height + (enemy.radius || enemy.height)) {
                    enemies.splice(i, 1);
                    if (!gameOver) score += 10; // 게임오버 아닐 때만 점수 추가
                    continue; // 다음 적으로 이동
                }

                // 플레이어와 충돌 감지
                let collided = false;
                if (enemy.type === 'normal') {
                    collided = detectCircleCollision(player, enemy);
                } else { // zigzag (사각형)
                     // 사각형 중심 좌표 기준으로 충돌 감지 함수 호출
                    collided = detectRectCollision(player, {
                        x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height
                    });
                }

                if (collided) {
                    if (player.shieldActive) {
                        enemies.splice(i, 1);
                        if (!gameOver) score += 50;
                    } else {
                        gameOver = true;
                        isGameRunning = false;
                        window.removeEventListener('deviceorientation', handleOrientation);
                        console.log("Game Over.");
                        break; // 루프 종료
                    }
                }
            } // 적 루프 끝

            // 아이템 이동 및 플레이어 충돌 처리
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.y += item.speed;

                // 화면 밖 제거
                if (item.y > canvas.height + (item.radius || item.height)) {
                    items.splice(i, 1);
                    continue;
                }

                // 플레이어와 충돌 감지
                let itemCollided = false;
                 if (item.type === 'score' || item.type === 'leaf') { // 원형 아이템
                    itemCollided = detectCircleCollision(player, item);
                 } else { // bee (사각형 아이템)
                     itemCollided = detectRectCollision(player, {
                         x: item.x, y: item.y, width: item.width, height: item.height
                     });
                 }

                if (itemCollided) {
                    activateItemEffect(item.type, player.x, player.y);
                    items.splice(i, 1); // 아이템 제거
                }
            } // 아이템 루프 끝

            // 발사체 이동 및 적 충돌 처리
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];

                // 발사체 이동
                if (proj.type === 'bee') {
                    proj.y += proj.speed; // speed가 음수이므로 위로 이동
                } else if (proj.type === 'leaf') {
                    proj.x += Math.cos(proj.angle) * proj.speed;
                    proj.y += Math.sin(proj.angle) * proj.speed;
                }

                // 화면 밖 제거
                if (proj.y < -proj.height || proj.y > canvas.height || proj.x < 0 || proj.x > canvas.width) {
                    projectiles.splice(i, 1);
                    continue;
                }

                // 적과 충돌 감지
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    let projCollided = false;

                    // 발사체(원 또는 사각형)와 적(원 또는 사각형) 충돌 감지
                    let projShape = proj.type === 'bee' ? { x: proj.x, y: proj.y, width: proj.width, height: proj.height } : { x: proj.x, y: proj.y, radius: proj.radius };
                    let enemyShape = enemy.type === 'normal' ? { x: enemy.x, y: enemy.y, radius: enemy.radius } : { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height };

                    if (proj.type === 'bee') { // 벌(사각형) vs 적
                        if (enemy.type === 'normal') { // vs 일반적(원)
                             projCollided = detectRectCollision(enemyShape, projShape);
                        } else { // vs 지그재그적(사각형) - 사각형 vs 사각형 충돌 (간단하게 중심 거리로 대체)
                            const dx = proj.x - enemy.x;
                            const dy = proj.y - enemy.y;
                            projCollided = Math.abs(dx) * 2 < (proj.width + enemy.width) && Math.abs(dy) * 2 < (proj.height + enemy.height);
                        }
                    } else { // 잎(원) vs 적
                         if (enemy.type === 'normal') { // vs 일반적(원)
                             projCollided = detectCircleCollision(projShape, enemyShape);
                         } else { // vs 지그재그적(사각형)
                             projCollided = detectRectCollision(projShape, enemyShape);
                         }
                    }


                    if (projCollided) {
                        enemies.splice(j, 1); // 적 제거
                        projectiles.splice(i, 1); // 발사체 제거
                        if (!gameOver) score += 30; // 발사체로 적 제거 시 점수
                        break; // 현재 발사체는 제거되었으므로 내부 루프 탈출
                    }
                }
            } // 발사체 루프 끝
        } // 업데이트 함수 끝

         // --- 그리기 함수 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!isGameRunning && !gameOver) return;

            // 플레이어 그리기
            ctx.beginPath(); ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2); ctx.fillStyle = player.color; ctx.fill(); ctx.closePath();
            // 보호막 그리기
            if (player.shieldActive) {
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)'; ctx.lineWidth = 3; ctx.stroke(); ctx.closePath();
            }

            // 적 그리기
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                if (enemy.type === 'normal') {
                    ctx.beginPath(); ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2); ctx.fill(); ctx.closePath();
                } else { // zigzag (사각형)
                    // 중심 좌표 기준으로 그리기
                    ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
                }
            });

            // 아이템 그리기
            items.forEach(item => {
                ctx.fillStyle = item.color;
                if (item.type === 'score' || item.type === 'leaf') { // 원형 또는 삼각형
                    if(item.type === 'leaf') { // 삼각형 그리기
                        ctx.beginPath();
                        ctx.moveTo(item.x, item.y - item.radius); // Top vertex
                        ctx.lineTo(item.x - item.radius * Math.cos(Math.PI / 6), item.y + item.radius * Math.sin(Math.PI / 6)); // Bottom left
                        ctx.lineTo(item.x + item.radius * Math.cos(Math.PI / 6), item.y + item.radius * Math.sin(Math.PI / 6)); // Bottom right
                        ctx.closePath();
                        ctx.fill();
                    } else { // 원형 (점수)
                        ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.closePath();
                    }
                } else { // bee (사각형)
                     ctx.fillRect(item.x - item.width / 2, item.y - item.height / 2, item.width, item.height);
                }
            });

             // 발사체 그리기
            projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                if (proj.type === 'bee') {
                    ctx.fillRect(proj.x - proj.width / 2, proj.y - proj.height / 2, proj.width, proj.height);
                } else if (proj.type === 'leaf') {
                    ctx.beginPath(); ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2); ctx.fill(); ctx.closePath();
                }
            });

            // 점수 표시
            ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.textAlign = 'left';
            ctx.fillText('Score: ' + score, 10, 30);

            // 게임 오버 표시
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);
                ctx.fillStyle = 'white'; ctx.font = '40px Arial'; ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.font = '20px Arial';
                ctx.fillText('Tap to Restart', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        // --- 게임 루프 ---
        function gameLoop(currentTime) {
            if (!isGameRunning && !gameOver) {
                 animationFrameId = requestAnimationFrame(gameLoop);
                 return;
            }
            if (gameOver) {
                 draw(); // 마지막 게임 오버 화면
                 return;
            }

            update(currentTime);
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- 게임 시작 함수 ---
        function startGame() {
            if (isGameRunning) return;
            initializeGameVariables();
            isGameRunning = true;
            lastEnemySpawnTime = Date.now(); // 적 생성 타이머 시작 시간
            lastItemSpawnTime = Date.now(); // 아이템 생성 타이머 시작 시간
            console.log("Game started.");
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- 초기 화면으로 복귀 함수 ---
        function resetToInitialScreen() {
             startButton.classList.remove('hidden');
             canvas.classList.add('hidden');
             controlsInfoDiv.classList.add('hidden');
             shieldInfoDiv.classList.add('hidden');
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             if (animationFrameId) cancelAnimationFrame(animationFrameId); // 루프 중지
             window.removeEventListener('deviceorientation', handleOrientation); // 리스너 제거
             console.log("Reset to initial screen.");
        }

        // PC용 키보드 컨트롤 테스트 (기기 센서 없을 때 사용)
        window.addEventListener('keydown', function(e) {
            // 게임이 실행 중일 때만 키보드 입력 처리
            if (isGameRunning) {
                if (e.key === 'ArrowLeft') {
                    player.x = Math.max(player.radius, player.x - 10);
                }
                else if (e.key === 'ArrowRight') {
                    player.x = Math.min(canvas.width - player.radius, player.x + 10);
                }
                else if (e.key === 'ArrowUp') {
                    player.y = Math.max(player.radius, player.y - 10);
                }
                else if (e.key === 'ArrowDown') {
                    player.y = Math.min(canvas.height - player.radius, player.y + 10);
                }
                else if (e.key === ' ' && !player.shieldActive && player.shieldCooldownTimer <= 0) {
                    // 스페이스바로 보호막 활성화
                    activateShield();
                }
            }
        });

        // 초기 상태 설정
        resetToInitialScreen(); // 페이지 로드 시 초기 화면 표시

        // 디버깅용 코드 - 적과 아이템을 수동으로 생성하여 테스트
        function debugSpawnItems() {
            // 적 생성 테스트
            enemies.push({
                x: canvas.width / 2,
                y: 50,
                radius: enemyRadius,
                speed: 2,
                type: 'normal',
                color: 'red'
            });
            
            // 아이템 생성 테스트
            items.push({
                x: canvas.width / 3,
                y: 100,
                speed: 1.5,
                type: 'score',
                radius: itemRadius,
                color: 'lime'
            });
            
            console.log("Debug items spawned:", enemies.length, items.length);
        }

        // 시작 후 3초 뒤에 디버깅용 아이템 생성 (필요시 활성화)
        // setTimeout(debugSpawnItems, 3000);
    </script>
</body>
</html>
